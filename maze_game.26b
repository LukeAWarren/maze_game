  include div_mul.asm

  const noscore = 1

  ; room colors
  const BLACK = $00
  const WHITE = $0E

  const GRAY_DARK = $04
  const GRAY_LIGHT = $0C

  const GREEN_DARK = $B4
  const GREEN_LIGHT = $B8

  const ORANGE_DARK = $24
  const ORANGE_LIGHT = $28

  const PURPLE_DARK = $54
  const PURPLE_LIGHT = $58

  ; player colors
  const PINK = $4A
  const BLUE = $84

  ; alais registers
  dim coll_detect_x = b
  dim coll_detect_y = c

  ; input debouncing for joystick 0
  dim j0_debounce_up_down = d
  dim j0_debounce_left_right = e

  ; input debouncing for joystick 1
  dim j1_debounce_up_down = f
  dim j1_debounce_left_right = g

  ; current room the missiles are in
  dim room_number = h

  ; a bunch of registeres for dealing with the p1 object
  dim mx_mid = i
  dim my_mid = j
  dim p1_room = k

  dim p1_y = m
  dim p1_dx = p
  dim p1_dy = q
  dim p1_move_counter = r
  dim coll_detect_top = s
  dim coll_detect_bottom = t
  dim coll_detect_left = u
  dim coll_detect_right = v

  ; initialize the first room
  room_number = 0

  const room_right = 1
  const room_middle = 2
  const room_left = 3
  const room_top = 4
  const room_bottom = 5

  ; missle screen offset
  const scr_left_x = 18
  const scr_right_x = 142
  const scr_top_y = 4
  const scr_bot_y = 87
  const offscrn_y = 200

  const entry_gate_left_x = 22
  const entry_gate_right_x = 138
  const entry_gate_top_y = 8
  const entry_gate_bot_y = 79

  ; missile dimensions (defined first, used in collision constants)
  const missle0_height = 4
  const missle0_width = 4
  const missle0_width_bin = %00100000
  const missle1_height = 4
  const missle1_width = 4
  const missle1_width_bin = %00100000

  ; horizontal offset
  const pf_scr_x_offset = 18

  ; optimized X collision constants (same for both missiles)
  const m_x_left_edge = pf_scr_x_offset + 1          ; = 19
  const m_x_right_edge = pf_scr_x_offset - missle0_width + 1  ; = 15
  const m_x_right_edge_plus1 = m_x_right_edge - 1    ; = 14

  ; vertical offset
  const pf_scr_y_offset = 3

  ; optimized Y collision constants
  const m0_y_top_edge = pf_scr_y_offset + 1        ; = 4
  const m0_y_bottom_edge = pf_scr_y_offset - missle0_height  ; = -1 (will add to missiley)
  const m0_y_bottom_edge_minus1 = m0_y_bottom_edge + 1       ; = 0
  const m1_y_top_edge = pf_scr_y_offset + 2        ; = 5
  const m1_y_top_edge_minus1 = pf_scr_y_offset + 1 ; = 4
  const m1_y_bottom_edge_minus1 = pf_scr_y_offset - missle1_height + 1  ; = 0
  const m1_y_bottom_edge_minus2 = pf_scr_y_offset - missle1_height + 2  ; = 1

  ; missle 0 setup
  COLUP0 = BLUE
  missile0height = missle0_height - 1
  missile0x = 60
  missile0y = 52

  ; missle 1 setup
  COLUP1 = PINK
  missile1height = missle1_height - 1
  missile1x = 100
  missile1y = 52

  ; frames to wait before auto-repeat
  const j_debounce_delay = 4

  ; a bunch of p1 constants
  ; elapsed frames between player1 movements towards the midpoint
  const p1_move_delay = 3
  const p1_gate_threshold = 2 ; how close the p1 sprite is to the gate to pass through

  p1_move_counter = 0

  player1:
    %11110000
    %10010000
    %10010000
    %11110000
end
  player1x = 94
  player1y = 52

  ; p1 starts in room 1
  p1_room = 1

mainloop
  NUSIZ0 = missle0_width_bin ; four pixels wide
  NUSIZ1 = missle1_width_bin ; four pixels wide

  if !joy0up && !joy0down then j0_debounce_up_down = 0

j0_up

  ; the joy up is not pressed then always set debounce counter 0
  if !joy0up then goto skip_j0_up

    if missile0y <= scr_top_y then goto skip_j0_up

      ; calculate top y pos
      coll_detect_y = ((missile0y - m0_y_top_edge) / 8)

      ; get the left x pos
      coll_detect_x = ((missile0x - pf_scr_x_offset) / 4)
      if pfread(coll_detect_x, coll_detect_y) then goto skip_j0_up

      ; get the right x pos
      coll_detect_x = ((missile0x - m_x_right_edge) / 4)
      if pfread(coll_detect_x, coll_detect_y) then goto skip_j0_up

      if j0_debounce_up_down = 0 || j0_debounce_up_down > j_debounce_delay then missile0y = missile0y - 1

      j0_debounce_up_down = j0_debounce_up_down + 1

skip_j0_up

j0_down
  if !joy0down goto skip_j0_down

    if missile0y >= scr_bot_y then goto skip_j0_down

      ; calculate bottom y pos
      coll_detect_y = ((missile0y - m0_y_bottom_edge) / 8)

      ; get the right x pos
      coll_detect_x = ((missile0x - m_x_right_edge) / 4)
      if pfread(coll_detect_x, coll_detect_y) then goto skip_j0_down

      ; get the left x pos
      coll_detect_x = ((missile0x - pf_scr_x_offset) / 4)
      if pfread(coll_detect_x, coll_detect_y) then goto skip_j0_down

      if j0_debounce_up_down = 0 || j0_debounce_up_down > j_debounce_delay then missile0y = missile0y + 1

      j0_debounce_up_down = j0_debounce_up_down + 1

skip_j0_down

  if !joy0left && !joy0right then j0_debounce_left_right = 0

j0_left
  if !joy0left goto skip_j0_left

    if missile0x <= scr_left_x then goto skip_j0_left
      ; get the left x
      coll_detect_x = ((missile0x - m_x_left_edge) / 4)

      ; get the top y
      coll_detect_y = ((missile0y - pf_scr_y_offset) / 8)
      if pfread(coll_detect_x, coll_detect_y) then goto skip_j0_left

      ; get the bottom y
      coll_detect_y = ((missile0y - m0_y_bottom_edge_minus1) / 8)
      if pfread(coll_detect_x, coll_detect_y) then goto skip_j0_left

      if j0_debounce_left_right = 0 || j0_debounce_left_right > j_debounce_delay then missile0x = missile0x - 1

      j0_debounce_left_right = j0_debounce_left_right + 1

skip_j0_left

j0_right
  if !joy0right goto skip_j0_right

    if missile0x >= scr_right_x then goto skip_j0_right
      ; get the right x
      coll_detect_x = ((missile0x - m_x_right_edge_plus1) / 4)

      ; get the top y
      coll_detect_y = ((missile0y - pf_scr_y_offset) / 8)
      if pfread(coll_detect_x, coll_detect_y) then goto skip_j0_right

      ; get the bottom y
      coll_detect_y = ((missile0y - m0_y_bottom_edge_minus1) / 8)
      if pfread(coll_detect_x, coll_detect_y) then goto skip_j0_right

      if j0_debounce_left_right = 0 || j0_debounce_left_right > j_debounce_delay then missile0x = missile0x + 1

      j0_debounce_left_right = j0_debounce_left_right + 1

skip_j0_right

  if !joy1up && !joy1down then j1_debounce_up_down = 0

j1_up
  if !joy1up goto skip_j1_up

    if missile1y <= scr_top_y then goto skip_j1_up

      ; calculate top y pos
      coll_detect_y = ((missile1y - m1_y_top_edge) / 8)

      ; get the left x pos
      coll_detect_x = ((missile1x - pf_scr_x_offset) / 4)
      if pfread(coll_detect_x, coll_detect_y) then goto skip_j1_up

      ; get the right x pos
      coll_detect_x = ((missile1x - m_x_right_edge) / 4)
      if pfread(coll_detect_x, coll_detect_y) then goto skip_j1_up

      if j1_debounce_up_down = 0 || j1_debounce_up_down > j_debounce_delay then missile1y = missile1y - 1

      j1_debounce_up_down = j1_debounce_up_down + 1

skip_j1_up

j1_down
  if !joy1down goto skip_j1_down

    if missile1y >= scr_bot_y then goto skip_j1_down

      ; calculate bottom y pos
      coll_detect_y = ((missile1y - m1_y_bottom_edge_minus1) / 8)

      ; get the right x pos
      coll_detect_x = ((missile1x - m_x_right_edge) / 4)
      if pfread(coll_detect_x, coll_detect_y) then goto skip_j1_down

      ; get the left x pos
      coll_detect_x = ((missile1x - pf_scr_x_offset) / 4)
      if pfread(coll_detect_x, coll_detect_y) then goto skip_j1_down

      if j1_debounce_up_down = 0 || j1_debounce_up_down > j_debounce_delay then missile1y = missile1y + 1

      j1_debounce_up_down = j1_debounce_up_down + 1

skip_j1_down

  if !joy1left && !joy1right then j1_debounce_left_right = 0

j1_left
  if !joy1left goto skip_j1_left
    if missile1x <= scr_left_x then goto skip_j1_left
      ; get the left x
      coll_detect_x = ((missile1x - m_x_left_edge) / 4)

      ; get the top y
      coll_detect_y = ((missile1y - m1_y_top_edge_minus1) / 8)
      if pfread(coll_detect_x, coll_detect_y) then goto skip_j1_left

      ; get the bottom y
      coll_detect_y = ((missile1y - m1_y_bottom_edge_minus2) / 8)
      if pfread(coll_detect_x, coll_detect_y) then goto skip_j1_left

      if j1_debounce_left_right = 0 || j1_debounce_left_right > j_debounce_delay then missile1x = missile1x - 1

      j1_debounce_left_right = j1_debounce_left_right + 1

skip_j1_left

j1_right
  if !joy1right goto skip_j1_right

    if missile1x >= scr_right_x then goto skip_j1_right
      ; get the right x
      coll_detect_x = ((missile1x - m_x_right_edge_plus1) / 4)

      ; get the top y
      coll_detect_y = ((missile1y - m1_y_top_edge_minus1) / 8)
      if pfread(coll_detect_x,coll_detect_y) then goto skip_j1_right

      ; get the bottom y
      coll_detect_y = ((missile1y - m1_y_bottom_edge_minus2) / 8)
      if pfread(coll_detect_x,coll_detect_y) then goto skip_j1_right

      if j1_debounce_left_right = 0 || j1_debounce_left_right > j_debounce_delay then missile1x = missile1x + 1

      j1_debounce_left_right = j1_debounce_left_right + 1

skip_j1_right

_begin_boundary_check

  if room_number = 0 then goto _inititial_game_room
  if room_number = room_right then goto _room_right_boundary_check
  if room_number = room_middle then goto _room_middle_boundary_check
  if room_number = room_left then goto _room_left_boundary_check
  if room_number = room_top then goto _room_top_boundary_check
  if room_number = room_bottom then goto _room_bottom_boundary_check

_end_boundary_check


  ; if p1_align_midpoint then gosub _p1_place_at_midpoint
_begin_p1_logic

  ; always skip one frame after showing p1, m0 and m1 in the room together
  ; this makes it seem like p1 has to notice in the room them before moving toward them
  if p1_room = room_number && player1y = offscrn_y then goto _end_p1_logic
  ; if p1 is in the same room as the missiles and it's currently on the screen
  ; then calculate a new position for p1
  if p1_room = room_number && player1y <> offscrn_y then goto _calc_pos_and_move_p1
  ; if the missiles are not in the room with the player
  ; but the player is visible then hide it
  if p1_room <> room_number && player1y <> offscrn_y then goto _save_and_hide_p1
  ; if the missiles are not in the room with the player
  ; and the player is already offscreen don't do anything
  if p1_room <> room_number && player1y = offscrn_y then goto _end_p1_logic

_save_and_hide_p1  
  p1_y = player1y
  player1y = offscrn_y
  p1_move_counter = 0
  goto _end_p1_logic
_calc_pos_and_move_p1
  
  ; calculate midpoint between m0 and m1

  dim mid_delta = temp3
  dim mid_delta_half = temp4

  ; calculate horizontal midpoint
  if missile0x > missile1x then goto _m0_x_right_of_m1_x
    mid_delta = missile1x - missile0x
    mid_delta_half = mid_delta / 2
    mx_mid = missile1x - mid_delta_half
    mx_mid = mx_mid - 1
    goto _end_m0_m1_horizontal_midpoint
_m0_x_right_of_m1_x
  mid_delta = missile0x - missile1x
  mid_delta_half = mid_delta / 2
  mx_mid = missile0x - mid_delta_half
  mx_mid = mx_mid - 1
_end_m0_m1_horizontal_midpoint

  ; calculate vertical midpoint
  if missile0y > missile1y then goto _m0_y_right_of_m1_y
    mid_delta = missile1y - missile0y
    mid_delta_half = mid_delta / 2
    my_mid = missile1y - mid_delta_half
    goto _end_m0_m1_vertical_midpoint
_m0_y_right_of_m1_y
  mid_delta = missile0y - missile1y
  mid_delta_half = mid_delta / 2
  my_mid = missile0y - mid_delta_half
_end_m0_m1_vertical_midpoint

  ; only step every p1_move_delay frames
  p1_move_counter = p1_move_counter + 1
  if p1_move_counter <= p1_move_delay then goto _end_p1_logic
  p1_move_counter = 0

  ; the p1 sprite is already at the midpoint of the two missile sprites
  if player1x = mx_mid && player1y = my_mid then goto _end_p1_logic

  ; determine which direction p1 should move
  if player1x = mx_mid then p1_dx = 0 : goto _end_set_p1_dx
  if player1x < mx_mid then p1_dx = 1 else p1_dx = -1
_end_set_p1_dx

  if player1y = my_mid then p1_dy = 0 : goto _end_set_p1_dy
  if player1y < my_mid then p1_dy = 1 else p1_dy = -1
_end_set_p1_dy

_begin_p1_up
  if p1_dy <> -1 then goto _end_p1_up
    coll_detect_top = ((player1y - 5) / 8)
    coll_detect_left = ((player1x - 17) / 4)
    if pfread(coll_detect_left, coll_detect_top) then goto _end_p1_up
      coll_detect_right = ((player1x - 14) / 4)
    if pfread(coll_detect_right, coll_detect_top) then goto _end_p1_up
    player1y = player1y - 1
_end_p1_up

_begin_p1_down
  if p1_dy <> 1 then goto _end_p1_down
    coll_detect_bottom = (player1y / 8)
    coll_detect_left = ((player1x - 17) / 4)
    if pfread(coll_detect_left, coll_detect_bottom) then goto _end_p1_down
      coll_detect_right = ((player1x - 14) / 4)
    if pfread(coll_detect_right, coll_detect_bottom) then goto _end_p1_down
    player1y = player1y + 1
_end_p1_down

_begin_p1_right
  if p1_dx <> 1 then goto _end_p1_right
    coll_detect_right = ((player1x - 13) / 4)
    coll_detect_top = ((player1y - 4) / 8)
    if pfread(coll_detect_right, coll_detect_top) then goto _end_p1_right
      coll_detect_bottom = ((player1y - 1) / 8)
    if pfread(coll_detect_right, coll_detect_bottom) then goto _end_p1_right
    player1x = player1x + 1
_end_p1_right

_begin_p1_left
  if p1_dx <> -1 then goto _end_p1_left
    coll_detect_left = ((player1x - 18) / 4)
    coll_detect_top = ((player1y - 4) / 8)
    if pfread(coll_detect_left, coll_detect_top) then goto _end_p1_left
      coll_detect_bottom = ((player1y - 1) / 8)
    if pfread(coll_detect_left, coll_detect_bottom) then goto _end_p1_left
    player1x = player1x - 1
_end_p1_left

_end_p1_logic

  drawscreen
  goto mainloop


_room_right
  if room_number = room_middle then missile0x = entry_gate_left_x : missile1x = entry_gate_left_x
_inititial_game_room
  room_number = room_right
  COLUBK = BLACK
  COLUPF = WHITE
  playfield:
    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
    X..............................X
    X..............................X
    X..............................X
    ..............XXXX.............X
    ..............XXXX.............X
    X..............................X
    X..............................X
    X..............................X
    X..............................X
    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
    ................................
end
  goto _end_boundary_check
_room_right_boundary_check
  if missile0x <= scr_left_x && missile1x <= scr_left_x then goto _room_middle
  goto _end_boundary_check
_skip_room_right_boundary_check

_room_middle
  ; depending on which room we came from
  ; set the correct horizonal or vertical starting position
  if room_number = room_right then missile0x = entry_gate_right_x : missile1x = entry_gate_right_x
  if room_number = room_left then missile0x = entry_gate_left_x : missile1x = entry_gate_left_x
  if room_number = room_top then missile0y = entry_gate_top_y : missile1y = entry_gate_top_y
  if room_number = room_bottom then missile0y = entry_gate_bot_y : missile1y = entry_gate_bot_y
  room_number = room_middle
  COLUBK = ORANGE_DARK
  COLUPF = ORANGE_LIGHT
  playfield:
    XXXXXXXXXXXXXX....XXXXXXXXXXXXXX
    X..............................X
    X..............................X
    X..............................X
    ................................
    ................................
    X..............................X
    X..............................X
    X..............................X
    X..............................X
    XXXXXXXXXXXXXX....XXXXXXXXXXXXXX
    ................................
end
  goto _end_boundary_check
_room_middle_boundary_check
  if missile0x >= scr_right_x && missile1x >= scr_right_x then goto _room_right
  if missile0x <= scr_left_x && missile1x <= scr_left_x then goto _room_left
  if missile0y <= scr_top_y && missile1y <= scr_top_y then goto _room_top
  if missile0y >= scr_bot_y && missile1y >= scr_bot_y then goto _room_bottom
  goto _end_boundary_check
_skip_room_middle_boundary_check

_room_left
  if room_number = room_middle then missile0x = entry_gate_right_x : missile1x = entry_gate_right_x
  room_number = room_left
  COLUBK = GRAY_DARK
  COLUPF = GRAY_LIGHT
  playfield:
    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
    X..............................X
    X..............................X
    X..............................X
    X...............................
    X...............................
    X..............................X
    X..............................X
    X..............................X
    X..............................X
    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
    ................................
end
  goto _end_boundary_check
_room_left_boundary_check
  if missile0x >= scr_right_x && missile1x >= scr_right_x then goto _room_middle
  goto _end_boundary_check
_skip_room_left_boundary_check

_room_top
  if room_number = room_middle then missile0y = entry_gate_bot_y : missile1y = entry_gate_bot_y
  room_number = room_top
  COLUBK = GREEN_DARK
  COLUPF = GREEN_LIGHT
  playfield:
    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
    X..............................X
    X..............................X
    X..............................X
    X..............................X
    X..............................X
    X..............................X
    X..............................X
    X..............................X
    X..............................X
    XXXXXXXXXXXXXX....XXXXXXXXXXXXXX
    ................................
end
  goto _end_boundary_check
_room_top_boundary_check
  if missile0y >= scr_bot_y && missile1y >= scr_bot_y then goto _room_middle
  goto _end_boundary_check
_skip_room_top_boundary_check

_room_bottom
  if room_number = room_middle then missile0y = entry_gate_top_y : missile1y = entry_gate_top_y
  room_number = room_bottom
  COLUBK = PURPLE_DARK
  COLUPF = PURPLE_LIGHT
  playfield:
    XXXXXXXXXXXXXX....XXXXXXXXXXXXXX
    X..............................X
    X..............................X
    X..............................X
    X..............................X
    X..............................X
    X..............................X
    X..............................X
    X..............................X
    X..............................X
    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
    ................................
end
  goto _end_boundary_check
_room_bottom_boundary_check
  if missile0y <= scr_top_y && missile1y <= scr_top_y then goto _room_middle
  goto _end_boundary_check
_skip_room_bottom_boundary_check
